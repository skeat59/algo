 \documentclass [11pt]{report}

\usepackage{fancyhdr}
\usepackage [french]{babel}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{titlepic}

\usepackage{listings}
\usepackage{minitoc}
\usepackage{footmisc}
\usepackage{color}
\usepackage{graphicx}

\usepackage{tikz}
\usetikzlibrary{arrows}

\usetikzlibrary{trees}


\usepackage{eso-pic}
\pagestyle{fancy}	

\tikzset{
  treenode/.style = {align=center, inner sep=0pt, text centered,
    font=\sffamily},
 arn_r/.style = {treenode, circle, black, draw=black, 
     text width=1.5em, very thick},
  arn_r/.style = {treenode, circle, black, draw=black, 
    text width=1.5em, very thick},
  arn_x/.style = {treenode, rectangle, draw=black,
    minimum width=0.5em, minimum height=0.5em}% arbre rouge noir, nil
}


\begin{document}
{\huge Gdalia Thibault}\\
\indent {\huge Sup D2}\\
\vspace{20mm}\\
\begin{center}
{\Huge Devoir Maison}\\ {\LARGE \textit{13 Mai 2014}}\\
\end{center}
\vspace{110mm}
\begin{flushright}
Epita Promo 2019\\
\end{flushright}
\newpage
\underline{{\huge Exercice 1}}\\
\indent \underline{question 1:} \vspace{2.5mm}
	 repr\'esentation par tas de la figure 1.\\
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline 5 & 8 & 12 & 9 & 11 & 20 & 15 & 18 & 10 & 13 \\ 
\hline 
\end{tabular} 

\vspace{5mm}

\indent \underline{question 2:}\\
a- La racine se trouve a place 1 du vecteur.\\
b- Les fils d'un nœud se trouve \`a 2x(place du nœud) et \`a 2x(position du nœud) + 1 \\
c- Pour retrouver le p\`ere d'un noeud il faut faire (position du nœud) div 2. O\`u div est la division enti\`ere\\
d- Le nœud est une feuille dans le cas ou les cases du vecteur 2x(position du nœud) et 2x(position du nœud) + 1 sont vide ou si elle n'existe pas\\
e- Un nœud est un point simple si l'une des cases, correspondant a ses fils, dans le vecteur est vide.\\

\vspace{10mm}

\underline{{\huge Exercice 2:}}\\
\indent \underline{question 1: Ajout}\\
\indent a- On ajoute l'\'el\'ement en feuille, puis on le fais remonter en l'\'echangeant avec son p\`ere jusqu'a ce qu'il se trouve a sa place. c'est-\`a-dire lorsque son p\`ere est inf\'erieur au nouvel \'el\'ement.\\
\indent b- Apr\`es l'ajout de la valeur 4:

\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 5cm/#1,
  level distance = 1.5cm}] 
\node [arn_r] {4}
    child{ node [arn_r] {5} 
            child{ node [arn_r] {9} 
            	child{ node [arn_r] {18}} 
				child{ node [arn_r] {10}}
            }
            child{ node [arn_r] {8}
							child{ node [arn_r] {13}}
							child{ node [arn_r] {11}}
            }                            
    }
    child{ node [arn_r] {12}
            child{ node [arn_r] {20} 
            	child {node [arn_x] {}}
            	child {node [arn_x] {}}        	
          	}
            child{ node [arn_r] {15}
            	child{node [arn_x] {}}
            	child{node [arn_x]{}}
            }
   };
\end{tikzpicture}
\\
\vspace{2.5mm}\\
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
\hline K & J & I & B & Q & C & G & D & F & E & H \\ 
\hline 4 & 5 & 12 & 9 & 8 & 20 & 15 & 18 & 10 & 13 & 11 \\ 
\hline 
\end{tabular} \\
\vspace{10mm}\\
\indent Apr\`es l'ajout de 10:\\
\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 5cm/#1,
  level distance = 1.5cm}] 
\node [arn_r] {4}
    child{ node [arn_r] {5} 
            child{ node [arn_r] {9} 
            	child{ node [arn_r] {18}} 
				child{ node [arn_r] {10}}
            }
            child{ node [arn_r] {8}
							child{ node [arn_r] {13}}
							child{ node [arn_r] {11}}
            }                            
    }
    child{ node [arn_r] {10}
            child{ node [arn_r] {12} 
            	child {node [arn_r] {20}}
               child{ node [arn_r] {15}} 	
  			}
  			child{ node [arn_x]{}}         
   };
\end{tikzpicture}\\
\vspace{2.5mm}\\
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline K & J & L  & B & Q & I  & D  & F  & E  & H  & C  & G \\ 
\hline 4 & 5 & 10 & 9 & 8 & 12 & 18 & 10 & 13 & 11 & 20 & 15\\ 
\hline 
\end{tabular} \\
\vspace{5mm}\\
 c- algorithme d'ajout dans un tas:\\
algorithme procedure ajout\\
\indent parametres globaux\\
\indent \indent t\_tas tas\\
\indent parametres locaux\\
\indent \indent t\_element elt\\
\indent \indent reel val\\
\indent variables\\
\indent \indent t\_tas tmp\\
debut\\
\indent taille <- taille + 1\\
\indent place <- taille\\
\indent tas[place] <- (elt,val)\\
\indent tant que tas[place] < tas[place div 2] faire\\
\indent \indent tmp[1] <- tas[place div 2]\\
\indent \indent place <- place div 2\\
\indent \indent tas[place] <- tas[taille]\\
\indent \indent tas[taille] <- tmp[1]\\
\indent  fin tant que\\
fin algorithme procedure ajout\\
d- la complexit\'e de cet algo est O(log(n))\\
\vspace{7.5mm}\\
2-supression\\
\indent a- La valeur minimum est la premi\`ere valeur du tas, donc la racine de l'arbre. Pour la supprimer on la passe en feuille, pour cela on l'\'echange avec le dernier \'el\'ement du tas. Puis on remet la nouvelle racine a sa place dans le tas pour que l'on continue a respecter la relation d'ordre. \\
\vspace{5mm}\\
\indent b- le tas apr\`es la supression de la valeur minimum.\\
\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 5cm/#1,
  level distance = 1.5cm}] 
\node [arn_r] {5}
    child{ node [arn_r] {8} 
            child{ node [arn_r] {9} 
            	child{ node [arn_r] {18}} 
				child{ node [arn_r] {10}}
            }
            child{ node [arn_r] {11}
							child{ node [arn_r] {13}}
							child{ node [arn_r] {20}}
            }                            
    }
    child{ node [arn_r] {10}
            child{ node [arn_r] {12} 
            	child {node [arn_x] {}}
            	child {node [arn_x] {}}        	
          	}
            child{ node [arn_r] {15}
            	child{node [arn_x] {}}
            	child{node [arn_x]{}}
            }
   };
\end{tikzpicture}\\
\vspace{2mm}\\
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
\hline J & Q & F  & B & H  & I  & G  &  D & L  & E  & C \\ 
\hline 5 & 8 & 10 & 9 & 11 & 12 & 15 & 18 & 10 & 13 & 20 \\ 
\hline 
\end{tabular} \\
 c- Alorithme de suppression \\
algorithme procedure suppression\\
\indent parametres globaux \\
\indent \indent t\_tas tas\\
\indent variables\\
\indent \indent entier place\\
debut \\
\indent swap(tas.elt[1], tas.elt[taille])\\
\indent taille <- taille - 1\\
\indent place <- 1\\
\indent tant que (tas[place] > tas[2*place] ou tas[place] > tas[2*place + 1]) faire \\
\indent \indent si tas[2*place] < tas[2*place + 1] alors\\
\indent \indent \indent	swap(tas[place], tas[2*place])\\
\indent \indent \indent	place <- 2*place\\
\indent \indent	sinon\\
\indent \indent \indent	swap(tas[place], tas[2*place + 1])\\
\indent \indent \indent	place <- 2*place + 1\\
\indent \indent	fin si\\
\indent fin tant que\\
fin algorithme procedure suppression\\
\vspace{5mm}\\
 d- la complexite de cette algorithme est de l'autre de O(log(taille du tas))
 \vspace{10mm}\\
 \underline{{\huge Exercice 3:}}\\
\underline{question 1: Minimisation}\\
\indent a- Modification de la valeur de H par 4\\
\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 5cm/#1,
  level distance = 1.5cm}] 
\node [arn_r] {4}
    child{ node [arn_r] {5} 
            child{ node [arn_r] {9} 
            	child{ node [arn_r] {18}} 
				child{ node [arn_r] {10}}
            }
            child{ node [arn_r] {8}
							child{ node [arn_r] {13}}
							child{ node [arn_r] {20}}
            }                            
    }
    child{ node [arn_r] {10}
            child{ node [arn_r] {12} 
            	child {node [arn_x] {}}
            	child {node [arn_x] {}}        	
          	}
            child{ node [arn_r] {15}
            	child{node [arn_x] {}}
            	child{node [arn_x]{}}
            }
   };
\end{tikzpicture}\\
\vspace{2mm}\\
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
\hline H & J & F  & B & Q & I  & G  &  D & L  & E  & C \\ 
\hline 4 & 5 & 10 & 9 & 8 & 12 & 15 & 18 & 10 & 13 & 20 \\ 
\hline 
\end{tabular} \\
\vspace{5mm}\\
\indent \underline{ b- algorithme modif\_tas:}\\
\indent algorithme procedure modif\_tas\\
\indent \indent parametres globaux\\
\indent \indent \indent t\_tas t\\
\indent \indent parametres locaus\\
\indent \indent \indent t\_element elt\\
\indent \indent \indent reel x\\
\indent \indent variables\\
\indent \indent \indent entier r\\
\indent debut\\
\indent \indent r <- 1\\
\indent \indent tant que tas.elt[r] <> elt faire\\
\indent \indent \indent r <- r+1\\
\indent \indent fin tant que\\
\indent \indent tas[r] <- (elt, x)\\
\indent \indent tant que tas[r] < tas[r div 2]\\
\indent \indent \indent swap(tas[r], tas[r div 2])\\
\indent \indent \indent r <- r div 2\\
\indent \indent fin tant que\\
\indent fin algorithme modif\_tas\\
\vspace{5mm}\\
\underline{Question 2: Optimisation}\\
\indent a-La COmplexit\'e d'un algorithme de recherche est O(taille du tas).\\
\indent b- Si on avait l'ancienne valeur de l'\'el\'ement \`a modifi\'e on pourrait le trouvait plus rapidement et la complexit\'e passerait \`a O(log(taille du tas)).
\end{document}